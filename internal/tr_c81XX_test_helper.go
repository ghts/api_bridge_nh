package internal

import (
	"github.com/ghts/lib"

	"testing"
	"time"
)

func f매수주문_테스트_도우미(t *testing.T, 계좌번호 string, 종목 *lib.S종목,
	호가유형 lib.T호가유형, 가격, 수량 int64) int64 {
	lib.F대기(lib.P1초)

	var 주문번호 int64

	// 매수
	매수주문_질의값 := new(lib.S질의값_정상주문)
	매수주문_질의값.TR구분 = lib.TR주문
	매수주문_질의값.TR코드 = lib.NH_TR주식_매수
	매수주문_질의값.M증권사 = lib.P증권사_NH
	매수주문_질의값.M계좌번호 = 계좌번호
	매수주문_질의값.M매수_매도 = lib.P매수
	매수주문_질의값.M종목코드 = 종목.G코드()
	매수주문_질의값.M주문수량 = 수량
	매수주문_질의값.M주문단가 = 가격
	매수주문_질의값.M호가유형 = 호가유형
	매수주문_질의값.M주문조건 = lib.P주문조건_없음

	소켓_메시지, 에러 := lib.New소켓_메시지(lib.F임의_변환형식(), 매수주문_질의값)
	lib.F테스트_에러없음(t, 에러)

	질의 := lib.New채널_질의(ch주문, lib.P10초, 1).S질의(소켓_메시지)

	데이터_수신_완료, 완료_통보_수신_완료 := false, false

	for {
		응답 := 질의.G응답()
		lib.F테스트_에러없음(t, 응답.G에러())

		구분, ok := 응답.G값(0).(lib.TR응답_구분)
		lib.F테스트_참임(t, ok, 응답)

		lib.F테스트_같음(t, 구분, lib.TR응답_데이터, lib.TR응답_완료)

		//lib.F문자열_출력("매수 %v", 구분.String())

		switch 구분 {
		case lib.TR응답_데이터:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			switch 변환값.G자료형_문자열() {
			case lib.F자료형_문자열(lib.NH주식_정상주문_응답{}):
				매수주문_응답 := new(lib.NH주식_정상주문_응답)
				lib.F테스트_다름(t, 변환값.G자료형_문자열(), "<nil>")
				lib.F테스트_에러없음(t, 변환값.G값(매수주문_응답))
				lib.F테스트_참임(t, 매수주문_응답.M주문번호 > 0, 매수주문_응답.M주문번호)
				lib.F테스트_같음(t, 매수주문_응답.M매수_매도, lib.P매수)
				lib.F테스트_같음(t, 매수주문_응답.M주문_단가, 가격)
				lib.F테스트_같음(t, 매수주문_응답.M주문_수량, 수량)
				주문번호 = 매수주문_응답.M주문번호
				데이터_수신_완료 = true
			default:
				lib.F문자열_출력("예상치 못한 자료형. %v", 변환값.G자료형_문자열())
				t.FailNow()
			}
		case lib.TR응답_완료:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			if 변환값.G자료형_문자열() != "<nil>" {
				lib.New에러("예상하지 못한 자료형. %v", 변환값.G자료형_문자열())
			}

			완료_통보_수신_완료 = true
		}

		if 데이터_수신_완료 && 완료_통보_수신_완료 {
			break
		}
	}

	// 실시간 정보 수신 (접수, 체결)
	//누적_체결량 := int64(0)
	접수_완료 := false

	//lib.F문자열_출력("매수주문 실시간 정보 수신 시작")

	for {
		주문_응답 := <-ch주문_응답

		lib.F테스트_다름(t, 주문_응답, nil)
		lib.F테스트_같음(t, 주문_응답.RT코드, lib.NH_RT주문_접수, lib.NH_RT주문_체결)
		p1분전 := time.Now().Add(-1 * lib.P1분)
		p1분후 := time.Now().Add(lib.P1분)

		//lib.F문자열_출력("%v", 주문_응답.RT코드)

		switch 주문_응답.RT코드 {
		case lib.NH_RT주문_접수:
			lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_정상)
			lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
			lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
			lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매수)
			lib.F테스트_같음(t, 주문_응답.M수량, 수량)
			lib.F테스트_참임(t, 주문_응답.M가격 > 0, 주문_응답.M가격)
			lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
			lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
			lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
			lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
			접수_완료 = true
		//case RT주문_체결:
		//	lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_정상)
		//	lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
		//	lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
		//	lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매수)
		//	lib.F테스트_같음(t, 주문_응답.M수량, 수량)
		//	lib.F테스트_참임(t, 주문_응답.M가격 > 0, 주문_응답.M가격)
		//	lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
		//	lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
		//	lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
		//	lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
		//	누적_체결량 += 주문_응답.M수량
		default:
			lib.New에러("예상하지 못한 RT코드. %v", 주문_응답.RT코드)
			t.FailNow()
		}

		//if 접수_완료 && 누적_체결량 == 수량 {
		if 접수_완료 {
			break
		}
	}

	return 주문번호
}

func f매도주문_테스트_도우미(t *testing.T, 계좌번호 string, 종목 *lib.S종목,
	호가유형 lib.T호가유형, 가격, 수량 int64) int64 {
	lib.F대기(lib.P500밀리초)

	var 주문번호 int64

	// 매도
	매도주문_질의값 := new(lib.S질의값_정상주문)
	매도주문_질의값.TR구분 = lib.TR주문
	매도주문_질의값.TR코드 = lib.NH_TR주식_매도
	매도주문_질의값.M증권사 = lib.P증권사_NH
	매도주문_질의값.M계좌번호 = 계좌번호
	매도주문_질의값.M매수_매도 = lib.P매도
	매도주문_질의값.M종목코드 = 종목.G코드()
	매도주문_질의값.M주문수량 = 수량
	매도주문_질의값.M주문단가 = 가격
	매도주문_질의값.M호가유형 = 호가유형
	매도주문_질의값.M주문조건 = lib.P주문조건_없음
	질의 := lib.New채널_질의(ch주문, lib.P10초, 1).S질의(매도주문_질의값)

	데이터_수신_완료, 완료_통보_수신_완료 := false, false

	for {
		응답 := 질의.G응답()
		lib.F에러_출력(응답.G에러())

		구분, ok := 응답.G값(0).(lib.TR응답_구분)
		lib.F테스트_참임(t, ok, 응답)

		lib.F테스트_같음(t, 구분, lib.TR응답_데이터, lib.TR응답_완료)

		lib.F문자열_출력("매도 %v", 구분.String())

		switch 구분 {
		case lib.TR응답_데이터:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			switch 변환값.G자료형_문자열() {
			case lib.F자료형_문자열(lib.NH주식_정상주문_응답{}):
				주문_응답 := new(lib.NH주식_정상주문_응답)
				lib.F테스트_다름(t, 변환값.G자료형_문자열(), "<nil>")
				lib.F테스트_에러없음(t, 변환값.G값(주문_응답))
				lib.F테스트_참임(t, 주문_응답.M주문번호 >= 0, 주문_응답.M주문번호)
				lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매도)
				lib.F테스트_같음(t, 주문_응답.M주문_단가, 가격)
				lib.F테스트_같음(t, 주문_응답.M주문_수량, 수량)

				데이터_수신_완료 = true
			default:
				lib.F문자열_출력("예상치 못한 자료형. %v", 변환값.G자료형_문자열())
				t.FailNow()
			}

		case lib.TR응답_완료:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			if 변환값.G자료형_문자열() != "<nil>" {
				lib.New에러("예상하지 못한 자료형. %v", 변환값.G자료형_문자열())
			}

			완료_통보_수신_완료 = true
		}

		if 데이터_수신_완료 && 완료_통보_수신_완료 {
			break
		}
	}

	// 실시간 정보 수신 (접수, 체결)
	누적_체결량 := int64(0)
	접수_완료 := false

	for {
		주문_응답 := <-ch주문_응답

		lib.F테스트_다름(t, 주문_응답, nil)
		lib.F테스트_같음(t, 주문_응답.RT코드, lib.NH_RT주문_접수, lib.NH_RT주문_체결)
		p1분전 := time.Now().Add(-1 * lib.P1분)
		p1분후 := time.Now().Add(lib.P1분)

		switch 주문_응답.RT코드 {
		case lib.NH_RT주문_접수:
			lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_정상)
			lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
			lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
			lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매도)
			lib.F테스트_같음(t, 주문_응답.M수량, 수량)
			lib.F테스트_참임(t, 주문_응답.M가격 > 0, 주문_응답.M가격)
			lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
			lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
			lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
			lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
			주문번호 = 주문_응답.M주문번호
			접수_완료 = true
		//case RT주문_체결:
		//	lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_정상)
		//	lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
		//	lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
		//	lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매도)
		//	lib.F테스트_같음(t, 주문_응답.M수량, 수량)
		//	lib.F테스트_참임(t, 주문_응답.M가격 > 0, 주문_응답.M가격)
		//	lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
		//	lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
		//	lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
		//	lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
		//	누적_체결량 += 주문_응답.M수량
		default:
			lib.New에러("예상하지 못한 RT코드. %v", 주문_응답.RT코드)
			t.FailNow()
		}

		if 접수_완료 && 누적_체결량 == 수량 {
			break
		}
	}

	return 주문번호
}

func f정정주문_테스트_도우미(t *testing.T, 계좌번호 string, 종목 *lib.S종목, 정정구분 lib.T잔량_일부,
	원주문번호, 가격, 수량 int64) int64 {
	lib.F대기(lib.P1초)

	var 주문번호 int64

	정정주문_질의값 := lib.New질의값_정정주문_NH()
	정정주문_질의값.TR구분 = lib.TR주문
	정정주문_질의값.TR코드 = lib.NH_TR주식_정정
	정정주문_질의값.M증권사 = lib.P증권사_NH
	정정주문_질의값.M계좌번호 = 계좌번호
	정정주문_질의값.M원주문번호 = 원주문번호
	정정주문_질의값.M종목코드 = 종목.G코드()
	정정주문_질의값.M주문수량 = 수량
	정정주문_질의값.M주문단가 = 가격
	정정주문_질의값.M잔량_일부 = 정정구분

	소켓_메시지, 에러 := lib.New소켓_메시지(lib.F임의_변환형식(), 정정주문_질의값)
	lib.F테스트_에러없음(t, 에러)

	질의 := lib.New채널_질의(ch주문, lib.P10초, 1).S질의(소켓_메시지)

	데이터_수신_완료, 완료_통보_수신_완료 := false, false

	for {
		응답 := 질의.G응답()
		lib.F테스트_에러없음(t, 응답.G에러())

		구분, ok := 응답.G값(0).(lib.TR응답_구분)
		lib.F테스트_참임(t, ok, 응답)

		switch 구분 {
		case lib.TR응답_데이터:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			switch 변환값.G자료형_문자열() {
			case lib.F자료형_문자열(주문번호):
				lib.F테스트_에러없음(t, 변환값.G값(&주문번호))
				lib.F테스트_참임(t, 주문번호 > 0, 주문번호)
				데이터_수신_완료 = true
			default:
				lib.F문자열_출력("예상치 못한 자료형. %v", 변환값.G자료형_문자열())
				t.FailNow()
			}
		case lib.TR응답_완료:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			if 변환값.G자료형_문자열() != "<nil>" {
				lib.New에러("예상하지 못한 자료형. %v", 변환값.G자료형_문자열())
			}
			완료_통보_수신_완료 = true
		default:
			lib.F문자열_출력("예상하지 못한 TR응답. %v", 구분)
		}

		if 데이터_수신_완료 && 완료_통보_수신_완료 {
			break
		}
	}

	// 실시간 정보 수신 (접수, 체결)
	접수_완료 := false
	체결_완료 := false

	for {
		주문_응답 := <-ch주문_응답

		lib.F테스트_다름(t, 주문_응답, nil)
		lib.F테스트_같음(t, 주문_응답.RT코드, lib.NH_RT주문_접수, lib.NH_RT주문_체결)
		p1분전 := time.Now().Add(-1 * lib.P1분)
		p1분후 := time.Now().Add(lib.P1분)

		switch 주문_응답.RT코드 {
		case lib.NH_RT주문_접수:
			lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_정정)
			lib.F테스트_참임(t, 주문_응답.M원주문번호 > 0, 주문_응답.M원주문번호)
			lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
			lib.F테스트_같음(t, 주문_응답.M주문번호, 주문번호)
			lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
			lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매수)

			lib.F메모("정정 주문 접수 d3 수량 이상함.")
			// lib.F테스트_같음(t, 주문_응답.M수량, 수량)

			lib.F테스트_같음(t, 주문_응답.M가격, 가격)
			lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
			lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
			lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
			lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
			접수_완료 = true
		case lib.NH_RT주문_체결:
			lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_정정)
			lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
			//lib.F테스트_참임(t, 주문_응답.M원주문번호 > 0, 주문_응답.M원주문번호)
			lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
			lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매수)

			lib.F메모("정정 주문 체결  d2 수량 이상함.")
			//lib.F테스트_같음(t, 주문_응답.M수량, 수량)

			lib.F테스트_참임(t, 주문_응답.M가격 > 0, 주문_응답.M가격)
			lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
			lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
			lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
			lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
			체결_완료 = true
		default:
			lib.New에러("예상하지 못한 RT코드. %v", 주문_응답.RT코드)
			t.FailNow()
		}

		if 접수_완료 && 체결_완료 {
			break
		}
	}

	return 주문번호
}

func f취소주문_테스트_도우미(t *testing.T, 계좌번호 string, 종목 *lib.S종목,
	취소구분 lib.T잔량_일부, 원주문번호, 수량 int64) int64 {
	lib.F대기(lib.P1초)

	var 주문번호 int64

	취소주문_질의값 := lib.New질의값_취소주문_NH()
	취소주문_질의값.TR구분 = lib.TR주문
	취소주문_질의값.TR코드 = lib.NH_TR주식_취소
	취소주문_질의값.M증권사 = lib.P증권사_NH
	취소주문_질의값.M계좌번호 = 계좌번호
	취소주문_질의값.M원주문번호 = 원주문번호
	취소주문_질의값.M종목코드 = 종목.G코드()
	취소주문_질의값.M주문수량 = 수량
	취소주문_질의값.M잔량_일부 = 취소구분

	소켓_메시지, 에러 := lib.New소켓_메시지(lib.F임의_변환형식(), 취소주문_질의값)
	lib.F테스트_에러없음(t, 에러)

	질의 := lib.New채널_질의(ch주문, lib.P10초, 1).S질의(소켓_메시지)

	데이터_수신_완료, 완료_통보_수신_완료 := false, false

	for {
		응답 := 질의.G응답()
		lib.F테스트_에러없음(t, 응답.G에러())

		구분, ok := 응답.G값(0).(lib.TR응답_구분)
		lib.F테스트_참임(t, ok, 응답)

		lib.F테스트_같음(t, 구분, lib.TR응답_데이터, lib.TR응답_완료)

		lib.F문자열_출력("취소 %v", 구분.String())

		switch 구분 {
		case lib.TR응답_데이터:
			lib.F테스트_같음(t, 응답.G길이(), 2)

			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			switch 변환값.G자료형_문자열() {
			case lib.F자료형_문자열(lib.NH주식_취소주문_응답{}):
				취소주문_응답 := lib.NH주식_취소주문_응답{}
				lib.F테스트_다름(t, 변환값.G자료형_문자열(), "<nil>")
				lib.F테스트_에러없음(t, 변환값.G값(&취소주문_응답))
				lib.F문자열_출력("%v", 취소주문_응답)
				lib.F테스트_참임(t, 취소주문_응답.M주문번호 > 0, 취소주문_응답.M주문번호)
				주문번호 = 취소주문_응답.M주문번호
				데이터_수신_완료 = true
			default:
				lib.F문자열_출력("예상치 못한 자료형. %v", 변환값.G자료형_문자열())
				t.FailNow()
			}
		case lib.TR응답_완료:
			lib.F테스트_같음(t, 응답.G길이(), 2)
			변환값, ok := 응답.G값(1).(*lib.S바이트_변환_매개체)
			lib.F테스트_참임(t, ok, 응답.G값(1))

			if 변환값.G자료형_문자열() != "<nil>" {
				lib.New에러("예상하지 못한 자료형. %v", 변환값.G자료형_문자열())
			}
			완료_통보_수신_완료 = true
		}

		if 데이터_수신_완료 && 완료_통보_수신_완료 {
			break
		}
	}

	// 실시간 정보 수신 (접수, 체결)
	접수_완료 := false
	체결_완료 := false

	for {
		주문_응답 := <-ch주문_응답

		lib.F테스트_다름(t, 주문_응답, nil)
		lib.F테스트_같음(t, 주문_응답.RT코드, lib.NH_RT주문_접수, lib.NH_RT주문_체결)
		p1분전 := time.Now().Add(-1 * lib.P1분)
		p1분후 := time.Now().Add(lib.P1분)

		switch 주문_응답.RT코드 {
		case lib.NH_RT주문_접수:
			lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_취소)
			lib.F테스트_참임(t, 주문_응답.M원주문번호 > 0, 주문_응답.M원주문번호)
			lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
			lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
			lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매수)
			lib.F테스트_같음(t, 주문_응답.M수량, 수량)

			lib.F테스트_같음(t, 주문_응답.M가격, 0)
			lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
			lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
			lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
			lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
			접수_완료 = true
		case lib.NH_RT주문_체결:
			lib.F테스트_같음(t, 주문_응답.M주문응답_구분, lib.P주문응답_취소)
			//lib.F테스트_참임(t, 주문_응답.M원주문번호 > 0, 주문_응답.M원주문번호)
			lib.F테스트_참임(t, 주문_응답.M주문번호 > 0, 주문_응답.M주문번호)
			lib.F테스트_같음(t, 주문_응답.M종목코드, 종목.G코드())
			lib.F테스트_같음(t, 주문_응답.M매수_매도, lib.P매수)
			lib.F테스트_같음(t, 주문_응답.M수량, 수량)

			lib.F테스트_같음(t, 주문_응답.M가격, 0)
			lib.F테스트_참임(t, 주문_응답.M시각.After(p1분전), 주문_응답.M시각, time.Now())
			lib.F테스트_참임(t, 주문_응답.M시각.Before(p1분후), 주문_응답.M시각, time.Now())
			lib.F테스트_같음(t, 주문_응답.M신용거래_구분, lib.P신용거래_해당없음)
			lib.F테스트_같음(t, 주문_응답.M대출일, time.Time{})
			체결_완료 = true
		default:
			lib.New에러("예상하지 못한 RT코드. %v", 주문_응답.RT코드)
			t.FailNow()
		}

		if 접수_완료 && 체결_완료 {
			break
		}
	}

	return 주문번호
}
